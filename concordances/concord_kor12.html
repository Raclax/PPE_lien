
<!DOCTYPE html>
<html lang="kor">
<head>
    <meta charset="UTF-8">
    <title>Concordances</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.2/css/bulma.min.css">
</head>
<body>
    <section class="section">
        <div class="container">
            <h1 class="title">Concordances</h1>
            <table class="table">
                <thead>
                    <tr>
                        <th class="has-text-right">Contexte gauche</th>
                        <th>Mot</th>
                        <th class="has-text-left">Contexte droit</th>
                    </tr>
                </thead>
                <tbody>

<tr><td>객체 간 </td><td>관계</td><td> 정의</td></tr>
<tr><td>객체 간 </td><td>관계</td><td> 정의</td></tr>
<tr><td>SQLite는 관계형 데이터베이스이므로 항목 간 </td><td>관계</td><td></td></tr>
<tr><td>대부분의 객체 </td><td>관계</td><td> 매핑(ORM) 라이브러리에서는</td></tr>
<tr><td>Room에서는 2가지 방법으로 항목 간 </td><td>관계</td><td></td></tr>
<tr><td>유형이 있는 </td><td>관계</td><td></td></tr>
<tr><td>접근 방식에서는 Room 항목 간 </td><td>관계</td><td></td></tr>
<tr><td>정의하고 SQL 쿼리에서 항목 간 </td><td>관계</td><td></td></tr>
<tr><td>데이터 클래스 접근 방식을 사용하여 </td><td>관계</td><td></td></tr>
<tr><td>일대일 </td><td>관계</td><td> 정의</td></tr>
<tr><td>두 항목 간의 일대일 </td><td>관계</td><td></td></tr>
<tr><td>하나의 하위 항목 인스턴스에 상응하는 </td><td>관계</td><td></td></tr>
<tr><td>User 항목과 Library 항목은 일대일 </td><td>관계</td><td></td></tr>
<tr><td>일대일 </td><td>관계</td><td></td></tr>
<tr><td>먼저 두 항목 간의 일대일 </td><td>관계</td><td></td></tr>
<tr><td>일대다 </td><td>관계</td><td> 정의</td></tr>
<tr><td>두 항목 간의 일대다 </td><td>관계</td><td></td></tr>
<tr><td>항목 인스턴스에만 상응할 수 있는 </td><td>관계</td><td></td></tr>
<tr><td></td><td>관계</td><td></td></tr>
<tr><td>일대다 </td><td>관계</td><td></td></tr>
<tr><td>일대일 </td><td>관계</td><td></td></tr>
<tr><td>먼저 두 항목 간의 일대다 </td><td>관계</td><td></td></tr>
<tr><td>다대다 </td><td>관계</td><td> 정의</td></tr>
<tr><td>두 항목 간의 다대다 </td><td>관계</td><td></td></tr>
<tr><td>Playlist 항목과 Song 항목은 다대다 </td><td>관계</td><td></td></tr>
<tr><td>다대다 </td><td>관계</td><td></td></tr>
<tr><td>다대다 </td><td>관계</td><td></td></tr>
<tr><td>없다는 점에서 다른 </td><td>관계</td><td> 유형과 구별됩니다. 대신 세 번째</td></tr>
<tr><td>참조 테이블에는 테이블에 표시된 다대다 </td><td>관계</td><td></td></tr>
<tr><td>associateBy 속성을 사용하여 항목 간의 </td><td>관계</td><td></td></tr>
<tr><td>Playlist 항목과 Song 항목 간의 </td><td>관계</td><td></td></tr>
<tr><td>쿼리에서 JOIN 키워드를 사용하여 적절한 </td><td>관계</td><td></td></tr>
<tr><td>중첩된 </td><td>관계</td><td> 정의</td></tr>
<tr><td>이 경우 테이블 간에 중첩된 </td><td>관계</td><td></td></tr>
<tr><td>중첩된 </td><td>관계</td><td></td></tr>
<tr><td>그러므로 쿼리에 중첩된 </td><td>관계</td><td></td></tr>
<tr><td>사용자는 재생목록과 일대다 </td><td>관계</td><td></td></tr>
<tr><td>가 있으며 재생목록은 노래와 다대다 </td><td>관계</td><td></td></tr>
<tr><td>아니라 재생목록과 노래 간의 다대다 </td><td>관계</td><td></td></tr>
<tr><td>집합 내 두 테이블 간의 </td><td>관계</td><td></td></tr>
<tr><td>Song 항목 클래스 간의 다대다 </td><td>관계</td><td></td></tr>
<tr><td>이 </td><td>관계</td><td></td></tr>
<tr><td>집합의 다른 테이블과 첫 번째 관계 클래스 간의 </td><td>관계</td><td>를 모델링하여 새</td></tr>
<tr><td></td><td>관계</td><td> 내부에</td></tr>
<tr><td>기존 </td><td>관계</td><td></td></tr>
<tr><td>관계 클래스 간의 일대다 </td><td>관계</td><td>를 모델링하는</td></tr>
<tr><td></td><td>관계</td><td></td></tr>
<tr><td>UserWithPlaylistsAndSongs는 User와 PlaylistWithSongs 간의 </td><td>관계</td><td></td></tr>
<tr><td>결과적으로 Playlist와 Song 간의 </td><td>관계</td><td></td></tr>
<tr><td>음악 스트리밍 앱 예에서 </td><td>관계</td><td> 클래스의 다이어그램</td></tr>
<tr><td>있다면 나머지 각 테이블 간의 </td><td>관계</td><td></td></tr>
<tr><td>및 이전의 모든 테이블 간의 </td><td>관계</td><td></td></tr>
<tr><td></td><td>관계</td><td> 클래스를 만듭니다. 이렇게 하면 쿼리하려는</td></tr>
<tr><td>모든 테이블 간에 중첩된 </td><td>관계</td><td> 체인이 생성됩니다</td></tr>
<tr><td>Room의 항목 간 </td><td>관계</td><td> 정의에 관한 자세한 내용은 다음</td></tr>
<tr><td>Room과의 데이터베이스 </td><td>관계</td><td></td></tr>

                </tbody>
            </table>
        </div>
    </section>
</body>
</html>

